[TOC]

# 前言

- MRC是在ARC没有出现前的荒蛮时代采用的管理引用计数的方法，学习它主要是为了能理解引用计数的问题，为理解属性关键字，ARC，特别是ARC中的Autoreleasepool

# 准备工作

- 开启MRC

  - [将项目改为MRC的方法(有图有真相)](https://blog.csdn.net/abelyulbb/article/details/51473445)

- 阅读完《Objective-C 高级编程》中的p.1 ~ 29

# 《高级编程》中的知识点

## 内存管理(引用计数)的思考(p.2 ~ p.13)
### 记住一张表格

| 对象 | 方法 | 引用计数 |
| :----------: | :-----------: | :--: |
| 生成对象并自己持有 | alloc/copy | 变成 1 |
| 持有对象 | Content Cell  | ++ |
| 释放对象 | release | -- |
| 废弃对象 | dealloc |  |
| 生成但不持有对象 | array | -1 |

### 四项基本原则

1. 自己生成的对象，自己持有
2. 非自己生成的对象，自己也能持有
3. 不再需要自己持有的对象时释放
4. 非自己持有的对象无法释放

#### 注意点
1. 我们不要纠结于引用计数的事，引用计数本质上只是一个帮助我们观察状态的工具，合理的思考方式就是按照上面四个原则去思考
2. 持有到底是什么意思？持有的本质其实就是强引用
```objective-c
NSObject *obj1 = [[NSObject alloc] init];
//这句话里面我们在内存中分配了一块空间，存放一个NSObject对象，而我们的obj1是一个指针，指向该对象
//同时，obj1也强引用即持有了该对象，会使该对象的引用计数+1
```

#### 疑点
1. 这里按照强应用即持有的观点，obj1持有了该对象，这和书上的是对象的使用环境（编程人员自身）持有对象这一观点不符
2. 但是如果按照书上的理解，实在很难想象为什么可以对象被多个持有