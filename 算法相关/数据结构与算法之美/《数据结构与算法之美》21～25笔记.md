[TOC]

# 关于我的仓库

- 这篇文章是我为面试准备的学习总结中的一篇
- 我将准备面试中找到的所有学习资料，写的Demo，写的博客都放在了这个仓库里[iOS-Engineer-Interview](https://github.com/KevinAshen/iOS-Engineer-Interview)
- 欢迎star👏👏
- 其中的博客在简书，CSDN都有发布
- 博客中提到的相关的代码Demo可以在仓库里相应的文件夹里找到

# 前言

- 该系列为学习《数据结构与算法之美》的系列学习笔记
- 总结规律为一周一更，内容包括其中的重要知识带你，以及课后题的解答
- 算法的学习学与刷题并进，希望能真正养成解算法题的思维
- LeetCode刷题仓库：[LeetCode-All-In](https://github.com/KevinAshen/LeetCode-All-In)
- 多说无益，你应该开始打代码了

# 21讲哈希算法（上）：如何防止数据库中的用户信息被脱库

- 哦，开局就是上古秘辛，2011年CSDN还是用明文保存的账户密码，这也忒靠谱了
- 幸好那个时候还不知道CSDN是个虾米玩意呢

## 哈希算法

- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）
- 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值

## MD5初识

- 之前在写网络下载的时候就大概了解过这个算法，这里正好讲到了，我就多查了点资料看了下
- 首先MD5被称之为不可逆算法，无法从哈希值逆推出原始数据，为什么MD5源码开放的情况下我们会无法逆推呢？因为在哈希过程中，我们不会去刻意保存原数据
- 比如我们进行了>>操作，将一个二进制数右移了两位，这样子必然会丢失掉最左边的两位，在这样的情况下就算我们有源码知道它进行了右移操作，进行左移，也无法得到原来的那两位，也就无法推倒到原来的数据【这只是一个很简单的例子】
- 所以对于这样的单向哈希算法，我们在意的只是加密这一过程，因此很多人说MD5不能算加密算法，因为加密会包括加密和解密，而MD5只管杀，不管埋，跟多的是视作一个生成数字签名的算法，从这个角度可能会更好理解这一部分
- 而我查到的资料提到2004年山东大学一位教授已经破译MD5，是说能够加快碰撞，就是说假如A哈希完结果是B，我现在能找到一个C哈希完也是B，加快了碰撞
- MD5“解密”过程正确来说不应该叫做“解密”，应该叫做MD5碰撞算法，只是拿到一个原始值再做一次MD5算法，看得到的的MD5值和你之前的MD5是不是一致，如果一致，我们就大体认为是原始值一致。为什么说大体呢？老师也说过了，会有HASH碰撞，可能不一样的原始值长生一样的HASH值，概率为1/2^128

## 哈希算法七应用【前四】

### 应用一：安全加密

- 加密哈希算法举例：**MD5**（MD5 Message-Digest Algorithm，MD5消息摘要算法）、**SHA**（Secure Hash Algorithm，安全散列算法）、 **DES**（Data Encryption Standard，数据加密标准）、**AES**（Advanced Encryption Standard，高级加密标准）
- 加密哈希算法的两个特点：
  - 第一点是很难根据哈希值反向推导出原始数据
  - 第二点是散列冲突的概率要很小
- 首先散列冲突一定会出现，这基于鸽巢原理【如果有10个鸽巢，有11只鸽子，那肯定有1个鸽巢中的鸽子数量多于1个，换句话说就是，肯定有2只鸽子在1个鸽巢内】
- 而以MD5举例，其哈希值是固定的128位二进制串，最多只有2^128个数据，而我们要哈希的数据是无限的
- 所有的安全措施，只是增加攻击的成本而已

### 应用二：唯一标识
- 这里假如我们要在图库里搜索一张图片是否存在，我们知道所有图片的本质是二进制，如果我们是根据二进制码一个一个对照搜索显然十分耗时【图片大的会有数MB，会很大】
- 我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量
- 如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识

### 应用三：数据校验

- BT下载的原理是基于P2P协议的。我们从多个机器上并行下载一个2GB的电影，这个电影文件可能会被分割成很多文件块（比如可以分成100块，每块大约20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了
- 这样就会存在，在某台机器上的资源看你是被恶意修改过的，或者是在下载过程中出现过问题，导致其文件块是不完整的
- 我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块
- 有趣啊，我感觉计算机最有意思的地方就是很多东西完全不是你空想能想到的，想这个数据校验会出现的情况就那么复杂

### 应用四：散列函数

- 散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决
- 散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率

### 解答开篇：守护最好的用户数据库

- 选择相对安全的加密算法
- 引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度
- 现在大多公司都采用无论密码长度多少，计算字符串hash时间都固定或者足够慢的算法如PBKDF2WithHmacSHA1，来降低硬件计算hash速度，减少不同长度字符串计算hash所需时间不一样而泄漏字符串长度信息，进一步减少风险

## 课后题：现在，区块链是一个很火的领域，它被很多人神秘化，不过其底层的实现原理并不复杂。其中，哈希算法就是它的一个非常重要的理论基础。你能讲一讲区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？

- 区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。
- 区块头保存着 自己区块体 和 上一个区块头 的哈希值。
- 因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。
- 区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。

# 22讲哈希算法（下）：哈希算法在分布式系统中有哪些应用

## 哈希算法七应用【后三】

- 个人认为这三点基本上都是一个东西本质上
- 就是说，怎么追求极致的均衡，方便扩容，缩容
- 所以思想都一样，注意下应用的场景吧，话说，我觉得这个网课真没白学，是挺有意思的，有一种世界开阔了的感觉

### 应用五：负载均衡

- 实现一个会话粘滞（session sticky）的负载均衡算法，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上
- 。**我们可以通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。** 这样，我们就可以把同一个IP过来的所有请求，都路由到同一个后端服务器上

### 应用六：数据分片

- 这个很像sideTables和sideTable的设计思想，面试的时候可以提一下，我觉得会高端很多，哈希真的运用很广泛，很有意思

#### 如何统计“搜索关键词”出现的次数？

- 假如我们有1T的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数
- 难点有两个，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长
- 针对方法就是先对数据分片，采用多台机器处理的方法，提高处理速度
- 为了提高处理的速度，我们用n台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号
- 这样能保证的是哈希值相同的机器会被分配到同一台机器

#### 如何快速判断图片是否在图库中？

- 假设我们的图库里面有上亿张图片，我们将无法简单的在一台机器上进行构建散列表
- 我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数n求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表
- 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找

### 应用七：分布式存储

- 参考[百话解析:一致性哈希算法 consistent hashing](http://www.zsythink.net/archives/1182)
- 假设我们有三台机器，将其哈希值对2的32次取余，投射到环上

![D8EBE958-67BD-425A-9777-F67A6A02F34B](https://tva1.sinaimg.cn/large/006y8mN6ly1g80422yuajj30cl0c4aau.jpg)

- 这样的好处在于：我们不用修改我们的哈希算法，不会出现同一个文件会被先后放到不同的服务器上
- 因为在这样的背景下，增加/去除服务器，只会影响到很小一部分的服务器，不会影响到所有人

![6D54F2FE-5512-4FB5-89FA-41C29CF1B5A8](https://tva1.sinaimg.cn/large/006y8mN6ly1g8046cts7vj30c30cdgm2.jpg)

- 同时，我们还会引入虚拟节点的概念，因为我们在环上的节点不一定均匀，有可能会导致某个服务器运作量大增

![B934E2EC-DCA8-4AB6-94B5-3D73C7249404](https://tva1.sinaimg.cn/large/006y8mN6ly1g804cfhcjej30cs0bu0t3.jpg)

- 真他娘的妙，这也许就是传说中的美丽的算法吧

# 23讲二叉树基础（上）：什么样的二叉树适合用数组来存储

- 终于到树的章节了，冲冲冲

## 基础概念

- 基本课上都讲过，滑一滑

![220043e683ea33b9912425ef759556ae](https://tva1.sinaimg.cn/large/006y8mN6ly1g8062ibw9sj30vq0dv3z3.jpg)

- A节点就是B节点的**父节点**，B节点是A节点的**子节点**。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为**兄弟节点**。我们把没有父节点的节点叫作**根节点**，也就是图中的节点E。我们把没有子节点的节点叫作**叶子节点**或者**叶节点**，比如图中的G、H、I、J、K、L都是叶子节点
- 分清楚高度 深度 叶子结点之类的问题是比较重要的

![4094a733986073fedb6b9d03f877d71e](https://tva1.sinaimg.cn/large/006y8mN6ly1g80ypzbx8pj30vq0fpwgs.jpg)

- 可以这么记：高度就是数有几楼，数的时候肯定是从下往上数的，所以根结点高度最高；深度就是从地平线往下数的，所以根结点会是0

## 二叉树（Binary Tree）

- 二叉树主要分清楚完全二叉树和满二叉树
- 满二叉树是完全二叉树的一种
- 全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树
![b151f8198618367a6f44126e2e738bd4b21ce5b0](https://tva1.sinaimg.cn/large/006y8mN6ly1g810npr9xmj30ez07e3yo.jpg)

- 特点：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大

![18413c6597c2850b75367393b401ad60](https://tva1.sinaimg.cn/large/006y8mN6ly1g810ot15z8j30vq0lvta9.jpg)

- 完全二叉树的定义来源于数组存储的顺序存储法，把根节点存储在下标i = 1的位置

![14eaa820cb89a17a7303e8847a412330](https://tva1.sinaimg.cn/large/006y8mN6ly1g810t89opaj30vq0gsjsd.jpg)

- 这样也就是完全按照编号作为数组下标去存储

![08bd43991561ceeb76679fbb77071223](https://tva1.sinaimg.cn/large/006y8mN6ly1g810uwpf2jj30vq0g90tp.jpg)

- 我们不能简单的对二叉树进行存储，必须要在遵循这样的规则的基础上去存储，标准很简单，就是能不能在这个数组的基础上重构出一棵二叉树
- 如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因
- 当我们讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组

## 二叉树的遍历

- codeRunner启动，开始打代码！
- 