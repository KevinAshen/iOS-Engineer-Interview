[TOC]

# 关于我的仓库

- 这篇文章是我为面试准备的学习总结中的一篇
- 我将准备面试中找到的所有学习资料，写的Demo，写的博客都放在了这个仓库里[iOS-Engineer-Interview](https://github.com/KevinAshen/iOS-Engineer-Interview)
- 欢迎star👏👏
- 其中的博客在简书，CSDN都有发布
- 博客中提到的相关的代码Demo可以在仓库里相应的文件夹里找到

# 前言

- 该系列为学习《数据结构与算法之美》的系列学习笔记
- 总结规律为一周一更，内容包括其中的重要知识带你，以及课后题的解答
- 算法的学习学与刷题并进，希望能真正养成解算法题的思维
- LeetCode刷题仓库：[LeetCode-All-In](https://github.com/KevinAshen/LeetCode-All-In)
- 多说无益，你应该开始打代码了

# 06讲链表(上):如何实现LRU缓存淘汰算法

- 常见缓存淘汰策略：先进先出策略FIFO(First In，First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)。
- 删除指定节点：由于删除节点需要使用前一个节点的next指针，所以对于单链表，在执行这样的删除，插入【前一个插入】的时候，都需要遍历链表
- 而双向链表对此就很有优势，包括对于有序链表查找，由于可以判定往后还是往前【此处存疑，怎么从中间开始？】
- 对于执行较慢的程序，可以通过消耗更多的内存(空间换时间)来进行优化;而消耗过多内存的程序，可以 通过消耗更多的时间(时间换空间)来降低内存的消耗。 ![BFB09C85-132D-417E-A24F-0D8F707D2F59](http://ww3.sinaimg.cn/large/006tNc79ly1g5xb9gmmooj31fo0k8wtz.jpg)
- 在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而 链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定 要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会 快于存储空间不连续的链表存储。
- 链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区 别。如果我们用ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据 的时候，ArrayList会申请一个1.5GB大小的存储空间，并且把原来那1GB的数据拷⻉到新申请的空间上。听起来是不是就很耗时?

## 实现LRU缓存淘汰算法

- 维护一个单向链表，越靠近尾节点越是远古且不常用
- 插入数据时：
  - 缓存已满，直接删除尾节点，将新数据插入头节点
  - 缓存不满：
    - 找到的该数据，删除原来的，在头节点加入
    - 找不到，直接在头节点加入

## 课后题：如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的思题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢?你有什么好的解决思路呢?相应的时间空间复杂度又是多少呢?【LeetCode 234 回文链表】

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == NULL || head->next == NULL) {
      return true;
    }

    ListNode *prev = NULL;
    ListNode *slow = head;
    ListNode *fast = head;

    while (fast != NULL && fast->next != NULL) {
      //pre：前一个
      //slow：慢指针&&后一段链表的开头
      //fast：快指针，边界工具人
      //操作就是要把慢指针经过的逆置过来，所以让pre作为前一个，slow作为当前工具人，使用next去记录下一个，就是slow的下一位
      //变换时，先把前面的逆过来，slow再往下走
      fast = fast->next->next;
      ListNode *next = slow->next;
      slow->next = prev;
      prev = slow;
      slow = next;
    }

    if (fast != NULL) {
      //！=NULL的这个情况就是奇数的情况，此时，slow工具人站在中间，pre就位，因此要让slow往前一个
      slow = slow->next;
    }

    while (slow != NULL) {
      if (slow->val != prev->val) {
        return false;
      }
      slow = slow->next;
      prev = prev->next;
    }

    return true;
    }
};
```

- 先通过快慢指针找到中点，此时链表分为两部分，把前半部分逆置，然后比较两列

# 07讲链表(下):如何轻松写出正确的链表代码
## 链表六技

### 技巧一：理解指针或引用的含义
- 指针的作用就在于存储对象的内存地址
- 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
- p->next=q：p结点中的next指针存储了q结点的内存地址
- p->next=p->next->next：p结点的next指针存储了p 结点的下下一个结点的内存地址。
### 技巧二：警惕指针丢失和内存泄漏
- 这一点其实就是由于链表单向性的特征，所以我们需要，我们一旦改变某一个节点的next指向，就会丢失掉原来那个
- 插入结点时，一定要注意操作的顺序
### 技巧三：利用哨兵简化实现难度
- 针对链表的插入，删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理
- 一个使用哨兵的例子：

```c
// 正常人写的代码
// 在数组a中，查找key，返回key所在的位置 // 其中，n表示数组a的⻓度
int find(char* a, int n, char key) {
// 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了 
  if(a == null || n <= 0) {
		return -1;
  }
	int i = 0;
// 这里有两个比较操作:i<n和a[i]==key. 
  while (i < n) {
  	if (a[i] == key) {
    	return i;
		}
		++i;
	}
	return -1;
}
```

```c
// 憨憨哨兵代码
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的⻓度
// 我举2个例子，你可以拿例子走一下代码 //a={4,2,3,5,9,6} n=6key=7 //a={4,2,3,5,9,6} n=6key=6 
int find(char* a, int n, char key) {
	if(a == null || n <= 0) { 
    return -1;
	}
// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值 
  if (a[n-1] == key) {
		return n-1;
  }
// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。 
// 之所以这样做的目的是:希望find()代码不要改变a数组中的内容 char tmp = a[n-1];
// 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7} 
  a[n-1] = key;
	int i = 0;
// while 循环比起代码一，少了i<n这个比较操作 
  while (a[i] != key) {
		++i;
  }
// 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6} 
  a[n-1] = tmp;
	if (i == n-1) {
// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1 
    return -1;
	} else {
// 否则，返回i，就是等于key值的元素的下标 
    return i;
	} 
}
```

- 简单来说，这么一整就可以使得少了i < n这个判断，🐂🍺
- 当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下， 我们并不需要如此追求极致的性能。【谁写谁憨说白了】
### 技巧四：重点留意边界条件处理
- 如果链表为空时，代码是否能正常工作?
- 如果链表仅包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
### 技巧五：举例画图，辅助思考

![page7image39834288.jpg](https://tva1.sinaimg.cn/large/006y8mN6ly1g6oy5xiv2nj30vq0hsgne.jpg) 

### 技巧六：多写多练，没有捷径

#### 单链表反转【LeetCode 206 反转链表】

##### 参考文章
- [LeetCode官方题解](https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/)
***
##### 题解
###### 我的题解
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
        ListNode *pre = NULL;
        ListNode *next = NULL;
        ListNode *pNode = head;
        
        while (pNode != NULL) {
            next = pNode->next;
            pNode->next = pre;
            pre = pNode;
            pNode = next;
        }
        
        return pre;
    }
};
```

***
###### 参考题解
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
       if (head == NULL || head->next == NULL) return head;
        ListNode *p = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return p;
    }
};
```
##### 反思

- 递归骚断腿，实在难悟
- 妙

#### 链表中环的检测【LeetCode 141 环形链表】

##### 参考文章
- [LeetCode官方题解](https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/)
***
##### 题解
###### 我的题解
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head == NULL || head->next == NULL) {
            return false;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while (fast->next != NULL && fast->next->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow->val == fast->val) {
                return true;
            }
        }
        return false;
    }
};
```

***
###### 参考题解
```c++
public boolean hasCycle(ListNode head) {
    Set<ListNode> nodesSeen = new HashSet<>();
    while (head != null) {
        if (nodesSeen.contains(head)) {
            return true;
        } else {
            nodesSeen.add(head);
        }
        head = head.next;
    }
    return false;
}
```
##### 反思

- 要想链表玩的溜，两根指针少不了

#### 两个有序的链表合并【LeetCode 21 合并两个有序链表】

##### 参考文章

- [LeetCode官方题解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/)

***
##### 题解
###### 我的题解
```c++
//这谁会呢
```

***
###### 参考题解
```c++
//递归
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
          	//这一步不仅是一开始的判空，更是后面当一个链表已经遍历到结束了
          	//就一直使用另一个里面的节点
            return l2;
        } 
        else if (l2 == NULL) {
            return l1;
        }
        else if (l1->val < l2->val) {
          	//由于从小到大，因此
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};

//迭代
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
      	//这等于就是添加哨兵的思想，使得不用考虑开头的数字，妙啊
        ListNode *prehead = new ListNode(-1);

      
        ListNode *prev = prehead;
        while (l1 != NULL && l2 != NULL) {
            if (l1->val <= l2->val) {
              	//把l1连上
                prev->next = l1;
              	//接下来要做的仅仅是把l1指针指向下一个
                l1 = l1->next;
            } else {
                prev->next = l2;
                l2 = l2->next;
            }
            prev = prev->next;
        }
        prev->next = l1 == NULL ? l2 :l1;

        return prehead->next;
    }
};
```
##### 反思

- 还是想太复杂了，其实只要进行一下链接就行，不用考虑辣么多

#### 删除链表倒数第n个结点【LeetCode 19 删除链表的倒数第N个节点】

##### 参考文章

- [LeetCode官方题解](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-by-l/)

##### 题解
###### 我的题解

```c++
//这谁会呢
```

***
###### 参考题解
```c++
//两次遍历算法
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        int length  = 0;
        ListNode *first = head;
        while (first != NULL) {
            length++;
            first = first->next;
        }
        length -= n;
        first = dummy;
        while (length > 0) {
            length--;
            first = first->next;
        }
        first->next = first->next->next;
        return dummy->next;
    }
};

//一次遍历法
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *first = dummy;
        ListNode *second = dummy;
        for (int i = 1; i <= n + 1; i++) {
            first = first->next;
        }
        while (first != NULL) {
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        return dummy->next;
    }
};
```
##### 反思

- 这又啥难的，惊了

#### 求链表的中间结点【LeetCode 876 链表的中间结点】

##### 参考文章

- [LeetCode官方题解](https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode/)

##### 题解

###### 我的题解
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *slowNode = head;
        ListNode *fastNode = head;
        while (fastNode->next != NULL && fastNode->next->next != NULL) {
            fastNode = fastNode->next->next;
            slowNode = slowNode->next;
        }
        if (fastNode->next != NULL) {
            slowNode = slowNode->next;
        }
        return slowNode;
    }
};
```

***
###### 参考题解
```c++
//这要啥参考题解呢
```
##### 反思

- 联动题目，回文链表

## 课后题：今天我们讲到用哨兵来简化编码实现，你是否还能够想到其他场景，利用哨兵可以大大地简化编码难度?

- 举例：iOS开发中，对于autoreleasing Pool那一块，在每个autoreleasingPool之间是靠哨兵对象nil隔开的
- 具体看我这篇博客[从RunTime源码回看autoreleasepool](https://www.jianshu.com/p/84511c5b3ecd)

# 08讲栈：如何实现浏览器的前进和后退功能

- 后进者先出，先进者后出，这就是典型的**“**栈**”**结构
- 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选**“**栈**”**这种数据结构。

## 顺序栈的基本实现

![EF09A73A-1691-4D2F-9818-FEBADC0B04A9](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vvcf9f8xj30qa0sfju1.jpg)

- 存储数据需要一个长度为n的数组并不是说空间复杂度就是O(n)，因为这n个空间是必须的，空间复杂度应该是算法所需要的额外存储空间

## 支持动态扩容的顺序栈

![page4image7848160.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vvfu5k2aj30ep0amdj3.jpg) 

- 最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)，使用摊还分析法分析

![page5image7775648.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vvi4idx8j30ep089wgh.jpg) 

- 总共涉及了K个数据的搬移，以及K次simple-push操作。将K个数据搬移均摊到K次入栈 操作，那每个入栈操作只需要一个数据搬移和一个simple-push操作。以此类推，入栈操作的均摊时间复杂度就为O(1)。
- 因为在大部分情况下，入 栈操作的时间复杂度O都是O(1)，只有在个别时刻才会退化为O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上， 平均情况下的耗时就接近O(1)。

## 典型使用

### 栈在函数调用中的应用【函数调用栈】

- 作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变 量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。
- 【程序员的自我修养p.287】:每一次函数的调用,都会在调用栈(call stack)上维护一个独立的栈帧(stack frame).每个独立的栈帧一般包括函数的返回地址和参数, 临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量, 保存的上下文【包括在函数调用前后需要不变的寄存器】

```c++
//
//  main.cpp
//  stack-Test
//
//  Created by Kevin.J on 2019/9/11.
//  Copyright © 2019 姜凯文. All rights reserved.
//

#include <iostream>

int add(int x, int y) {
    int sum = 0;
    sum = x + y;
    return sum;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n";
    
    int a = 1;
    int ret = 0;
    int res = 0;
    ret = add(3, 5);
    res = a + ret;
    printf("%d", res);
    return 0;
}
```

- 我们在add中打上一个断电，通过Xcode自带的LLDB来查看下栈帧

```objective-c
//输入 thread backtrace
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1
  * frame #0: 0x00000001000011d1 stack-Test`add(x=3, y=5) at main.cpp:13:11
    frame #1: 0x0000000100001234 stack-Test`main(argc=1, argv=0x00007ffeefbff5f0) at main.cpp:24:11
    frame #2: 0x00007fff6bf9f3d5 libdyld.dylib`start + 1
//当前顶上的就是add
```

![page6image7649056.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vwz7tnexj30ep07k400.jpg) 

### 栈在表达式求值中的应用

- 编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式， 当遇到数字，我们就直接压入操作数栈;当遇到运算符，就与运算符栈的栈顶元素进行比较。

![page7image8074704.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vwzu8vo0j30ep0a6tbd.jpg) 

- 这里还是要借助下西邮的数据结构课来说明比较妥当[表达式求值问题](https://www.icourse163.org/learn/XIYOU-1002578005?tid=1206775253#/learn/content?type=detail&id=1211637593)
- 数据优先级：

![0301B223-3494-44BE-B268-394991C9125E](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vx54du8sj310n0nfjxp.jpg)

- 这里的图画的不清楚，实际上在计算完8 * 5后得到40，会把40这个数重新压入数据栈，接下来也不会急着读取下一位，而是继续比较，发现减号优先级大于栈顶的加号，那就在处理加法，这时在比较遇到的是#，优先级比减号大了，此时才会把减号压入

### 栈在括号匹配中的应用

- 这个没什么好说的，就是遇到做括号入栈，遇到右括号出栈

## 通过栈实现浏览器的前进和后退

- 我们使用两个栈，X和Y，我们把首次浏览的⻚面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依 次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有⻚面可以 继续后退浏览了。当栈Y中没有数据，那就说明没有⻚面可以点击前进按钮浏览了。

![page8image7821888.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vx8i3tg5j30ep055aak.jpg) 

- 当你通过浏览器的后退按钮，从⻚面c后退到⻚面a之后，我们就依次把c和b从栈X中弹出，并且依次放入到栈Y。这个时候， 两个栈的数据就是这个样子:

![page8image7823680.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vx8sazypj30ep0550t9.jpg) 

- 这个时候你又想看⻚面b，于是你又点击前进按钮回到b⻚面，我们就把b再从栈Y中出栈，放入栈X中。此时两个栈的数据是这 个样子:

![page9image7397920.png](https://tva1.sinaimg.cn/large/006y8mN6ly1g6vx9wmv6jj30ep0553z1.jpg) 

## 课后题

### 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢?用其他数据结构 不行吗?

- 其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。

  从调用函数进入被调用函数，对于数据来说，变化的是什么呢?是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

### 我们都知道，JVM内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储Java中的对象。 那JVM里面的“栈”跟我们这里说的“栈”是不是一回事呢?如果不是，那它为什么又叫作“栈”呢?

- JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量。

## 作业

- leetcode上关于栈的题目大家可以先做20,155,232,844,224,682,496

# 09讲队列：队列在线程池等有限资源池中的应用

## 课后题

### 除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢?

### 今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢?