[TOC]

# 关于我的仓库

- 这篇文章是我为面试准备的学习总结中的一篇
- 我将准备面试中找到的所有学习资料，写的Demo，写的博客都放在了这个仓库里[iOS-Engineer-Interview](https://github.com/KevinAshen/iOS-Engineer-Interview)
- 欢迎star👏👏
- 其中的博客在简书，CSDN都有发布
- 博客中提到的相关的代码Demo可以在仓库里相应的文件夹里找到

# 前言

- 该系列为学习《数据结构与算法之美》的系列学习笔记
- 总结规律为一周一更，内容包括其中的重要知识带你，以及课后题的解答
- 算法的学习学与刷题并进，希望能真正养成解算法题的思维
- LeetCode刷题仓库：[LeetCode-All-In](https://github.com/KevinAshen/LeetCode-All-In)
- 多说无益，你应该开始打代码了

# 26讲红黑树（下）：掌握这些技巧，你也可以实现一个红黑树

- 下面这几节感觉以我的智力是顶不住了，了解为主吧，讲道理应该也不存在要你写个红黑树的

## 实现红黑树的基本思想

- 实现红黑树的过程就像是拼魔方一样，本质上你是要把每个步骤自己背下来，而不是自己去理解每一步的含义，而且还有case x转到case x这种操作，更像了
- 下面介绍下**左旋（rotate left）**、**右旋（rotate right）**，图中的a，b，r表示子树，可以为空

![0e37e597737012593a93105ebbf4591e](https://tva1.sinaimg.cn/large/006y8mN6ly1g8h5kn1wbnj30vq0jtmya.jpg)

![0AE5544A-66B9-40AA-94B0-A22A641D5F8D_1_105_c](https://tva1.sinaimg.cn/large/006y8mN6ly1g8h8ea0fz5j30sg0lc76s.jpg)

- 也就是说围绕哪个点进行左右旋就动哪个点，同时直接旋下来在进行一波调整

## 插入操作

- **红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上**
- 对于插入节点的父节点为黑色，或者插入节点本身就是根结点的情况，我们不需要进行任何操作【后一种情况直接改黑色就行】
- 除此之外的情况都会违背红黑树的定义，需要进行调整，包括左右旋和改变颜色
- 红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作**关注节点**。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点
- 新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡
- 我们下面依次来看每种情况的调整过程。提醒你注意下，为了简化描述，我把父节点的兄弟节点叫作叔叔节点，父节点的父节点叫作祖父节点

### CASE 1：如果关注节点是a，它的叔叔节点d是红色

- 将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色；
- 将关注节点a的祖父节点c的颜色设置成红色；
- 关注节点变成a的祖父节点c；
- 跳到CASE 2或者CASE 3

![603cf91f54b5db21bd02c6c5678ecf40](https://tva1.sinaimg.cn/large/006y8mN6ly1g8h9lpv4lfj30vq0h3gmj.jpg)

### CASE 2：如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点

- 关注节点变成节点a的父节点b；
- 围绕新的关注节点b左旋；
- 跳到CASE 3

![4480a314f9d83c343b8adbb28b6782ad](https://tva1.sinaimg.cn/large/006y8mN6ly1g8h9ma3fpkj30vq0hcdgr.jpg)

### CASE 3：如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点

- 围绕关注节点a的祖父节点c右旋；
- 将关注节点a的父节点b、兄弟节点c的颜色互换。
- 调整结束

![04650d9470b1e67899f5b8b7b8e33212](https://tva1.sinaimg.cn/large/006y8mN6ly1g8h9mn56pyj30vq0ns75o.jpg)

## 删除操作

- 第一步是**针对删除节点初步调整**。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
- 第二步是**针对关注节点进行二次调整**，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点

### 针对删除节点初步调整

- 红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红-黑”或者“黑-黑”。如果一个节点被标记为了“黑-黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。
- 在下面的讲解中，如果一个节点既可以是红色，也可以是黑色，在画图的时候，我会用一半红色一半黑色来表示。如果一个节点是“红-黑”或者“黑-黑”，我会用左上角的一个小黑点来表示额外的黑色

#### CASE 1：如果要删除的节点是a，它只有一个子节点b

- 删除节点a，并且把节点b替换到节点a的位置，这一部分操作跟普通的二叉查找树的删除操作一样
- 节点a只能是黑色，节点b也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点b改为黑色
- 调整结束，不需要进行二次调整

![a6c4c347b7cbdf57662bab399ed36cc3](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hob6gwh8j30vq0kajs7.jpg)

#### CASE 2：如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c

- 如果节点a的后继节点就是右子节点c，那右子节点c肯定没有左子树。我们把节点a删除，并且将节点c替换到节点a的位置。这一部分操作跟普通的二叉查找树的删除操作无异
- 然后把节点c的颜色设置为跟节点a相同的颜色
- 如果节点c是黑色，为了不违反红黑树的最后一条定义，我们给节点c的右子节点d多加一个黑色，这个时候节点d就成了“红-黑”或者“黑-黑”
- 这个时候，关注节点变成了节点d，第二步的调整操作就会针对关注节点来做

![48e3bd2cdd66cb635f8a4df8fb8fd64e](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hocogqz2j30vq0g7750.jpg)

#### CASE 3：如果要删除的是节点a，它有两个非空子节点，并且节点a的后继节点不是右子节点

- 找到后继节点d，并将它删除，删除后继节点d的过程参照CASE 1
- 将节点a替换成后继节点d
- 把节点d的颜色设置为跟节点a相同的颜色
- 如果节点d是黑色，为了不违反红黑树的最后一条定义，我们给节点d的右子节点c多加一个黑色，这个时候节点c就成了“红-黑”或者“黑-黑”；
- 这个时候，关注节点变成了节点c，第二步的调整操作就会针对关注节点来做

![b93c1fa4de16aee5482424ddf49f3c29](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hod8kz9vj30vq0i7757.jpg)

### 针对关注节点进行二次调整

- 经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点

#### CASE 1：如果关注节点是a，它的兄弟节点c是红色的

- 围绕关注节点a的父节点b左旋
- 关注节点a的父节点b和祖父节点c交换颜色
- 关注节点不变
- 继续从四种情况中选择适合的规则来调整

![ac76d78c064a2486e2a5b4c4903acb91](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hogqf0ljj30vq0ns75u.jpg)

#### CASE 2：如果关注节点是a，它的兄弟节点c是黑色的，并且节点c的左右子节点d、e都是黑色的

- 将关注节点a的兄弟节点c的颜色变成红色
- 从关注节点a中去掉一个黑色，这个时候节点a就是单纯的红色或者黑色
- 给关注节点a的父节点b添加一个黑色，这个时候节点b就变成了“红-黑”或者“黑-黑”
- 关注节点从a变成其父节点b
- 继续从四种情况中选择符合的规则来调整

![eca118d673c607eb2b103f3476fb24ec](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hohpbidmj30vq0htab4.jpg)

#### CASE 3：如果关注节点是a，它的兄弟节点c是黑色，c的左子节点d是红色，c的右子节点e是黑色

- 围绕关注节点a的兄弟节点c右旋
- 节点c和节点d交换颜色
- 关注节点不变
- 跳转到CASE 4，继续调整

![44075213100edd70315e1492422c92af](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hoi1b1a8j30vq0nsdhk.jpg)

#### CASE 4：如果关注节点a的兄弟节点c是黑色的，并且c的右子节点是红色的

- 围绕关注节点a的父节点b左旋
- 将关注节点a的兄弟节点c的颜色，跟关注节点a的父节点b设置成相同的颜色
- 将关注节点a的父节点b的颜色设置为黑色
- 从关注节点a中去掉一个黑色，节点a就变成了单纯的红色或者黑色
- 将关注节点a的叔叔节点e设置为黑色
- 调整结束

![5f73f61bf77a7f2bb75f168cf432ec44](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hoiewe7rj30vq0n9myq.jpg)

## 解答开篇：为什么红黑树的定义中，要求叶子节点是黑色的空节点？

- 其实是为了方便代入上述情况中去思考
- 同时不用考虑这样会造成内存浪费，因为我们可以使用同一个节点作为结尾节点

![d63231acb0e9d54c3469055d8dbdb366](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hoopntczj30vq0fv3zn.jpg)

# 27讲递归树：如何借助树来求解递归算法的时间复杂度【鸽了】

# 28讲堆和堆排序：为什么说堆排序没有快速排序快

## 如何理解“堆”

- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
- 对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”

## 如何实现一个堆？

- 由于堆是一个完全二叉树，所以我们可以使用数组去存储一个堆

![4d349f57947df6590a2dd1364c3b0b1e](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqd2htcjj30vq0f0q3m.jpg)

- 数组中下标为i的节点的左子节点，就是下标为i`*`2的节点，右子节点就是下标为i * 2 + 1的节点，父节点就是下标为i / 2的节点

## 往堆中插入一个元素

- 往堆中插入一个元素后，我们需要继续满足堆的两个特性
- 我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫作**堆化**（heapify）

### 自下而上的堆化方法

![e578654f930002a140ebcf72b11eb722](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqshgxg7j30vq0gxta1.jpg)

- 堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换

- 我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点
- 一直重复这个过程，直到父子节点之间满足刚说的那种大小关系

![e3744661e038e4ae570316bc862b2c0e](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqtaqc6vj30vq0lkjtw.jpg)

## 删除堆顶元素

### 会造成数组空洞的做法

- 假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中
- 然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除

![5916121b08da6fc0636edf1fc24b5a81](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqxunt75j30vq0o3dix.jpg)

- 就是说大的数据往上走

### 修正方法

- 修正方法的妙处在于，我们在删除了对顶元素后，把最后一个元素挪到堆顶，再进行堆化

- 同时这样的操作就是自上而下的堆化

![110d6f442e718f86d2a1d16095513260](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hr22pes0j30vq0ns0vm.jpg)

### 总结

- 我们知道，一个包含n个节点的完全二叉树，树的高度不会超过log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是O(log n)
- 插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)

## 实现堆排序

### 建堆

- 实现堆排序依然有两种实现方式，一种是不停插入实现，就像上面说的进行自下而上的堆化，本质上就是不同的插入数据，数据处理也只要从前往后处理即可
- 另一种就是自上而下的堆化过程，这里需要从后往前处理数据
- 由于我们是自上而下的过程，我们在堆化的过程中一定要保证节点的下家才能进行下去，因此我们的堆化过程是从最后一个非叶子结点开始的

![50c1e6bc6fe68378d0a66bdccfff441e](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hrh3nfgsj30vq0mfmz4.jpg)

- 在这段代码中，我们也可以发现，我们只需要对下标n / 2开始到1的数据进行堆化，下标是n / 2 + 1到n的节点是叶子节点，我们不需要堆化

### 排序

- 建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的
- 数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为n的位置
- 这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为n的元素放到堆顶，然后再通过堆化的方法，将剩下的n-1个元素重新构建成堆
- 堆化完成之后，我们再取堆顶的元素，放到下标是n-1的位置，一直重复这个过程，直到最后堆中只剩下标为1的一个元素，排序工作就完成了

![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hu97gjllj30vq0lytb5.jpg)

## 解答开篇：为什么快速排序要比堆排序性能好？

- 堆排序数据访问的方式没有快速排序友好，访问时不是顺序访问的，而是要跳着访问的，这对内存不是很友好
- 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。这会出现数据错乱，比如原本时接近有序的数据，反而被打乱

![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g8hugmektkj30vq0fxwg3.jpg)

## 课后题

### 在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从n / 2 + 1到n的节点是叶子节点，这个结论是怎么推导出来的呢？

- 使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。

- 为什么，对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：

- 如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点

- 备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算

### 我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？

- 堆的应用除了堆排以外，还有如下一些应用：
  1. 从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据
  2. 在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlockingQueue，当然它是线程安全的
  3. 可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists

## 代码实现堆排序

```c++
void HeapifyUpToDown(vector<int> &arr, int k, int i) {
	
	while (true) {
		int maxPos = i;
		if (i * 2 <= k && arr[i] < arr[i * 2]) {
			maxPos = i * 2;
		}
		if (i * 2 + 1 <= k && arr[maxPos] < arr[i * 2 + 1]) {
			maxPos = i * 2 + 1;
		}
		if (maxPos == i) {
			break;
		}
		swap(arr[i], arr[maxPos]);
		i = maxPos;
	}
}

// 从下往上建堆，即不停执行插入操作
void CreateHeapDownToUp(vector<int> &arr) {
	
	int arrLen = arr.size();
}

// 从上往下建堆，即从后往前遍历数组，进行堆化
void CreateHeapUpToDown(vector<int> &arr) {
	
	int arrLen = arr.size();
	for (int i = arrLen / 2; i >= 1; i--) {
		HeapifyUpToDown(arr, arrLen, i);
	}
	for (int &i : arr) {
		cout << i << endl;
	}
}



void HeapSort(vector<int> &arr) {
	
	int arrLen = arr.size();
	if (arrLen == 0) {
		return;
	}
	CreateHeapUpToDown(arr);
	int k = arrLen - 1;
	while (k > 1) {
		swap(arr[1], arr[k]);
		k--;
		HeapifyUpToDown(arr, k, 1);
	}
	
}

int main(int argc, char *argv[]) {
	vector<int> arr = {0, 7, 5, 19, 8, 4, 1, 20, 13, 16};
	HeapSort(arr);
	cout << "\n" << endl;
	for (int &i : arr) {
		cout << i << endl;
	}
}
```

# 29讲堆的应用：如何快速获取到Top10最热门的搜索关键词

- 又到了最长见识的应用课了，学起来

## 堆的应用一：优先级队列

- 用堆来实现优先级队列是最直接，高效的，因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列
- 很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素
- 从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素

### 合并有序小文件

- 假设我们有100个小文件，每个文件的大小是100MB，每个文件中存储的都是有序的字符串。我们希望将这些100个小文件合并成一个有序的大文件。这里就会用到优先级队列
- 整体思路有点像归并排序中的合并函数。我们从这100个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除
- 假设，这个最小的字符串来自于13.txt这个小文件，我们就再从这个小文件取下一个字符串，并且放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，并且将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止
- 这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。有没有更加高效方法呢？
- 这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将100个小文件中的数据依次放入到大文件中
- 我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)，n表示堆中的数据个数，这里就是100。

### 高性能定时器

- 假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如1秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行

![b04656d27fd0ba112a38a28c892069e7](https://tva1.sinaimg.cn/large/006y8mN6ly1g8jpqifjlwj30vq0dgmy2.jpg)

- 但是，这样每过1秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时
- 针对这些问题，我们就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务
- 这样，定时器就不需要每隔1秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔T
- 这个时间间隔T就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在T秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情
- 当T秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间
- 这样，定时器既不用间隔1秒就轮询一次，也不用遍历整个任务列表，性能也就提高了

## 堆的应用二：利用堆求Top K

- 我把这种求Top K的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。
- 针对静态数据，如何在一个包含n个数据的数组中，查找前K大数据呢？我们可以维护一个大小为K的小顶堆，顺序遍历数组，从数组中取出取数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前K大数据了。
- 遍历数组需要O(n)的时间复杂度，一次堆化操作需要O(logK)的时间复杂度，所以最坏情况下，n个元素都入堆一次，所以时间复杂度就是O(nlogK)。
- 针对动态数据求得Top K就是实时Top K。怎么理解呢？我举一个例子。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前K大数据。
- 如果每次询问前K大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是O(nlogK)，n表示当前的数据的大小。实际上，我们可以一直都维护一个K大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前K大数据，我们都可以里立刻返回给他。

## 堆的应用三：利用堆求中位数



