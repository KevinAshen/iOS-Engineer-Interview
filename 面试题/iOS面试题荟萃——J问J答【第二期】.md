[toc]

# 主演

- J先生：
  - 简介：单身帅气，热情潇洒，热爱iOS开发，目前在努力集齐苹果全家桶
  - GitHub：[KevinAshen](https://github.com/KevinAshen)
  - CSDN：[太阳骑士索拉尔](https://blog.csdn.net/KevinAshen)
  - 简书：[太阳骑士索拉尔](https://www.jianshu.com/u/0de1c21e79ca)
- J先生：
  - 简介：单身帅气，热情潇洒，热爱iOS开发，目前在努力集齐苹果全家桶
  - GitHub：[KevinAshen](https://github.com/KevinAshen)
  - CSDN：[太阳骑士索拉尔](https://blog.csdn.net/KevinAshen)
  - 简书：[太阳骑士索拉尔](https://www.jianshu.com/u/0de1c21e79ca)
- 说明：
	- 由于女主演罢工，本栏目被迫从男女知识问答互动节目改成沉闷单身男士自言自语节目
	- 参照节目从《国光帮帮忙》变成《晓说》
	- 不说了，眼泪要留下来了，各位观众不妨点个关注，加个赞，看看节目会进化成什么模式😢

## id相关

### id与instancetype的区别

- 知识补充之返回关联类型：

  - 描述：

    - 类方法中alloc，new开头
    - 实例方法中autorelease，init，retain，self开头

  - 代码：

    ```objective-c
    for example
    @interface NSObject
    +(id)alloc;
    -(id)init;
    @end
    ```

  - 特点：

    - 会返回方法所在类的类型的对象，即关联返回类型的方法
    - 这些方法的返回结果以方法所在的类为类型

  - 举例：

    - 返回关联类型代码：

      NSArray*array = [[NSArray alloc] init];

      - [NSArray alloc]返回类型属于关联返回类型，NSArray *

    - 非返回关联类型代码：

      ```objective-c
      // 定义
      @interface NSArray
      +(id)constructAnArray;
      @end
      // 调用
      [NSArray constructAnArray]
      ```

      - 得到返回类型和方法声明的返回类型一样，是id

- 引入instancetype的作用就在于能使得非关联返回类型的方法返回所在类的类型

- 比如对于[NSArray constructAnArray]，我们得到的返回值类型就会是NSArray *

- 好处：确定对象类型帮编译器更好定位代码问题

- 相同点：

  - 都可以作为方法的返回类型

- 不同点：

  - instancetype 可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。
  - instancetype只能作为返回值，id可以作为参数.
  - instancetype在编译的时候可以判断对象的真实类型

### id与NSObject *的区别

- NSObject *
  - 静态数据类型，会惊醒编译时检查（需要强制类型转换）
  - NSObject *无法管理到NSProxy
- id
  - 动态数据类型，不需要强制类型转换，可以直接使用，编译器不会检查其类型
  - id是万能指针，可以代表一切OC对象

### id的作用

- 可以用于动态绑定。编译器看到id以后，认为是动态类型，不再检查类型
- 多态, 可以减少代码量, 避免调用子类特有的方法需要强制类型转换
- 可以用于代理(delegate)。在声明代理的时候，根本不用关心代理的类型是什么
- 有的时候，你不知道变量的类型，就可以使用id。比如，在一个存储着NSString和NSNumber和数组中，想要找出所有的字符串。由于不确定取出的元素是哪种类型，就可以使用id进行声明，然后再判断类型

## 数据类型

### 静态数据类型与动态数据类型

- 静态数据类型
  - 特点:
    - 在编译时就知道变量的类型,
    - 知道变量中有哪些属性和方法
    - 在编译的时候就可以访问这些属性和方法,
    - 如果是通过静态数据类型定义变量, 如果访问不了属于静态数据类型的属性和方法, 那么编译器就会报错
- 动态数据类型
  - 特点:
    - 在编译的时候编译器并不知道变量的真实类型, 只有在运行的时候才知道它的真实类型
    - 如果通过动态数据类型定义变量, 如果访问了不属于动态数据类型的属性和方法, 编译器不会报错
  - 弊端：
    - 由于动态数据类型可以调用任意方法, 所以有可能调用到不属于自己的方法, 而编译时又不会报错, 所以可能导致运行时的错误
  - 应用场景: 
    - 多态, 可以减少代码量, 避免调用子类特有的方法需要强制类型转换
  - 使用须知：
    - 为了避免动态数据类型引发的运行时的错误, 一般情况下如果使用动态数据类型定义一个变量, 在调用这个对象的方法之前会进行一次判断, 判断当前对象是否能够调用这个方法